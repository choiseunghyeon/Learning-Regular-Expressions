# 정규표현식 (Regular Expression)

**_ test web page: https://www.regextester.com/ _**

## 무엇인가?

- 정규표현식은 텍스트를 찾고(검색) 조작(치환) 하는데 쓰는 문자열이다.

## flags

- g(global: 전역) 일치하는 모든 대상을 찾는다.
- i(ignore case: 대소문자 구별 무시) 대소문자 구분 없이 찾는다.

## Cheat Sheet

- . 모든 문자와 대응
- \ 역슬래시는 문자 그대로 해석하도록(이스케이프) 한다. 또는 특수한 문자 시퀀스를 시작하는 데 사용
- [] 문자 집합을 정의 (집합에 속한 문자가 모두 일치할 필요는 없다. / 메타문자는 문자 집합에서 문자로 인식된다. ex. [.] [+] 는 문자 . +와 일치한다.)
- \- 문자 범위 지정 \*대괄호 안에서만 메타 문자이다. ([0-9] [A-Z] [a-f])
- ^ 지정한 문자들을 제외한 어떤 것들과 일치시킨다. ([^0-9]) ex) 해당 범위의 숫자와 일치하지 않는다.
- \d 는 [0-9]와 같다.
- \D 는 [^0-9]와 같다.
- \w 는 [a-zA-z0-9_]와 같다.
- \W 는 [^a-za-z0-9_]와 같다.
- \s 는 모든 공백 문자 [\f\n\r\t\v]와 같다.
- \S 는 공백 문자가 아닌 모든 문자 [^\f\n\r\t\v]와 같다.
- \x 16진수 사용 ex) \x0A(아스키 문자 10) 줄바꿈 문자이며 \n과 같다.
- \0 8진수 사용 ex) \011(아스키 문자 9) 탭 문자이며 \t와 같다 / 두 자리나 세 자리 정수 앞에 \0붙여 표시
- \+ 하나 이상의 문자 찾기 ex) a+, [0-9]+
- \* 문자가 없거나 하나 이상 문자 찾기 ex a* [0-9]*
- ? 문자가 없거나 하나인 문자 찾기 ex https?
- 구간 찾기
  - 정확한 구간 찾기 {3}은 바로 앞에 있는 문자나 문자 집합이 세번 연속해서 일치 하는지 확인 ex) \d{3}
  - 범위 구간 찾기 {2,4} 최소 두 번 최대 네 번까지 일치 ex. ?는 {0,1}과 같다.
  - 최소 구간 찾기 {3,} 최소 세 번 일치 ex. +는 {1,}와 같고 \*는 {0,}와 같다.
- 위치 찾기 - 59p.
  - \b 단어 경계 지정 - \w와 \W 사이에 있는 위치와 일치 ex) \bcat\b - 위치를 가리키기 때문에 찾은 문자열의 개수는 3(c, a, t)이다.
  - ^ 문자열의 시작 - 문자 집합 바깥에서 사용해야 한다. ex) ^\s*<\?xml.*\?>
  - $ 문자열의 끝 - ex) </[Hh][tt][Mm][ll]>\s\*$
  - flag m 다중행 모드 (^ 문자열 시작, $ 문자열의 끝 작동방식에만 영향을 줌)
    - 참고: https://ko.javascript.info/regexp-multiline-mode
  - () 하위 표현식을 정의 (한 항목으로 취급한다.) ex. (&nbsp;){2,} 하위 표현식의 최소 구간 지정 - &nbsp;{2,}는 바로 앞에 있는 문자 ;의 최소 구간을 지정한 것
  - | OR 연산자를 의미 ex) 19|20 - 19혹은 20과 일치한다.
  - \1, \2 ... 역참조 \1은 처음 사용한 하위 표현식과 \2는 두 번째로 사용한 하위표현식과 일치 83p. (언어 마다 표현 방법이 다르다 JS에서는 \(역슬래시)를 사용)

## 치환

- $를 이용하여 역참조 $1, $2 ... n 번째 사용한 하위표현식과 일치는 똑같다. 87p. ex. "Hello, ben@forta.com is my email address.".replace(/(\w+[\w\.]\*@[\w\.]+\.\w+)/g, '<a href="mailto:$1">$1</a>')
- \E - \L혹은 \U 변환의 끝을 나타낸다. - 대소문자변환 JS에서 작동안하는듯 90p.
- \l 다음에 오는 글자를 소문자로 변환
- \L \E를 만날 때까지 모든 문자를 소문자로 변환
- \u 다음에 오는 글자를 대문자로 변환
- \U \E를 만날 때까지 모든 문자를 대문자로 변환

## 전후방탐색(lookaround) 92p.

- 자바, 닷넷, PHP, 파이썬, 펄에서는 몇 가지 제약이 있지만 후방 탐색을 지원한다. JS는 지원하지 않는다.
- 전방탐색(lookahead) 패턴은 일치 영역을 발견해도 그 값을 반환하지 않는 패턴을 말한다. 실제로는 **_하위표현식이며_**, 하위 표현식과 같은 형식으로 작성한다. ?= 시작 = 다음에 일치할 텍스트가 온다.
- 일부 정규 표현식 문서에서는 일치하는 영역을 반환하는 동작을 표현할 때 '소비한다(consume)'라는 용어를 쓴다. 이럴 경우 전방탐색은 '소비하지 않는다(not consume)'고 말한다.
- 후방탐색 연산자는 ?<= 이다.
- 부정형 전후방탐색 전후방탐색은 반환할 텍스트의 위치, 즉 찾고자 하는 부분의 앞뒤를 특별히 지정하고 싶을 때 주로 사용한다. 이런 방법들을 긍정형 전방탐색과 긍정형 후방탐색이라고 한다. 여기서 긍정이라는 말은 실제로 일치하는 텍스트를 찾기 때문이다. 그렇다면 **_부정형은 일치하지 않는 텍스트를 찾는다._**
- (?=) 긍정형 전방탐색 (?!) 부정형 전방탐색 (?<=) 긍정형 후방탐색 (?<!) 부정형 후방탐색

## Tips

- 정규표현식을 지칭하는 말로 패턴이라는 말을 자주 사용한다.
- 정규표현식과 문자열의 일치 영역(match)은 패턴과 일치하는 문자들 이다.
- 자주 쓰는 문자 집합들은 특수한 메타 문자로 대신하기도 한다. 이런 메타 문자들을 문자 클래스(classes of characters)라고 부른다.
- 이스케이프 문자와 같이 쓰여야 메타 문자가 되는 것도 있다. ( \n, \d, \D 등)
- \*, + 는 탐욕적 수량자로 가능한 큰 덩어리를 찾으려 한다. ?를 붙여 게으른 수량자로 바꿔 최소로 일치하도록 바꿀 수 있다. 57p.

## 2장 문자 하나 찾기 요약

- 정규 표현식을 이루는 문자열은 의미 그대로의 문자(text)일 수도 있고 메타 문자(특별한 의미를 지니는 특수문자)일 수도 있다. (ex: 모든 문자와 대응하는 .)
